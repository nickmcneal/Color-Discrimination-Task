<!-- <!DOCTYPE html> -->
<html>
    <head>
    <script src="jspsych/jspsych.js"></script>
    <script src="jspsych/plugins/jquery-3.5.1.min.js"></script>
    <script src="jspsych/plugins/jspsych-blocks.js"></script>
    <script src="jspsych/plugins/jspsych-image-keyboard-response.js"></script>
    <script src="jspsych/plugins/jspsych-blocks-exp.js"></script>
    <script src="jspsych/plugins/jspsych-rainbow.js"></script>
    <script src="jspsych/plugins/jspsych-call-function.js"></script>
    <script src="jspsych/plugins/jspsych-fullscreen.js"></script>
    <script src="jspsych/plugins/jspsych-html-keyboard-response.js"></script>
    <link rel="stylesheet" href="jspsych/css/jspsych.css">
</head>
<body></body>
<script>
    // Fixation duration, this is also currently used if the participant selects
    // "Space" -- neither Left or Right -- and no border is shown
    // for their selection
    const fixation_duration = 500; 
    
    var timeline = [];

    // Enter fullscreen:
    // timeline.push({
    // type: 'fullscreen',
    // fullscreen_mode: true
    // });


    var fixedfirst = true;
    if(Math.random() > .5){
        fixedfirst = true;
    } else{
        fixedfirst = false;
    }

    //Reward
    acc_reward = 10;

    var fixation = {
        type: 'html-keyboard-response',
        stimulus: '<div style="font-size:60px;">+</div>',
        choices: jsPsych.NO_KEYS,
        trial_duration: fixation_duration,
    };

    var colors = [
    'rgb(237,48,137)', 'rgb(226,62,153)', 'rgb(211,77,167)', 'rgb(193.5,90,177.5)', 'rgb(172,103,185)', 'rgb(149,113.5,189)', 'rgb(125,122,189)', 'rgb(100,129.5,184.5)'
    ]
    if(Math.random()>.5){
     colors.reverse();
    //  console.log("Array reversed.")
    }   

    var colors2 = [
    'rgb(82.5,142,91)', 'rgb(100,140,73)', 'rgb(117,137,56.5)', 'rgb(134,133,41)', 'rgb(152,127.5,28.5)', 'rgb(169,120,20)', 'rgb(186.5,111.5,19.5)', 'rgb(202,101,27)'
    ]

    if(Math.random()>.5){
     colors2.reverse();
    //  console.log("Array reversed.")
    }

    var j = 0;
    var w = 0; 
    var trial_count = 1; 
    var col1 = []


    if(Math.random() > .5){
        col1 = colors
    } else{
        col1 = colors2
    }



    
    function rainbow(z){

            var test=0;
    
            var ctx = z.getContext('2d');
            ctx.beginPath(); 
    
            ctx.fillStyle = col1[0];
            ctx.fillRect(125, 0, 100, 100);
    
            ctx.fillStyle = col1[1];
            ctx.fillRect(250, 0, 100, 100);
    
            ctx.fillStyle = col1[2];
            ctx.fillRect(375, 0, 100, 100);
    
            ctx.fillStyle = col1[3]; 
            ctx.fillRect(500, 0, 100, 100);
    
            ctx.fillStyle = col1[4];
            ctx.fillRect(625, 0, 100, 100);
    
            ctx.fillStyle = col1[5];
            ctx.fillRect(750, 0, 100, 100);
    
            ctx.fillStyle = col1[6];
            ctx.fillRect(875, 0, 100, 100);

            ctx.fillStyle = col1[7];
            ctx.fillRect(1000, 0, 100, 100);
    
            // ctx.fillStyle = colors[8];
            // ctx.fillRect(1000, 0, 100, 100);
    
            // ctx.fillStyle = colors[9];
            // ctx.fillRect(1125, 0, 100, 100);
    
            // console.log("RAINBOW")
        }
   

    function rainbow_values(rv){


        var ctx = rv.getContext('2d');
        ctx.font = "36px Times New Roman, sans-serif";
        ctx.fillStyle = "white"
        var n = 290 - 165

        //ctx.fillText("1", 40, 50);
        ctx.fillText("1", 165, 50);
        ctx.fillText("2", 290, 50);
        ctx.fillText("3", 290 + n, 50);
        ctx.fillText("4", 290 + 2*n, 50);
        ctx.fillText("5", 290 + 3*n, 50);
        ctx.fillText("6", 290 + 4*n, 50);
        ctx.fillText("7", 290 + 5*n, 50);
        ctx.fillText("8", 290 + 6*n, 50);
        // ctx.fillText("10", 290 + 7*n - 20, 50);

    }

   
    function rainbow_text(rv){

        var ctx = rv.getContext('2d');
        ctx.font = "24px Times New Roman, sans-serif";
        ctx.fillStyle = "white";
        // ctx.textAlign = 'center';
        //ctx.fillText("Colors farther to the right are worth more points.", 140, 50);
        ctx.fillText("Press the SPACE BAR to continue.", 450, 50);

    }

    function drawRectL(c){
        j = 0;

        var ctx = c.getContext('2d');
        ctx.beginPath(); 

        var a = Math.floor(Math.random()*8);
        ctx.fillStyle = col1[a];
        ctx.fillRect(0, 0, 100, 100);

        var b = Math.floor(Math.random()*8);
        ctx.fillStyle = col1[b];
        ctx.fillRect(125, 0, 100, 100);
       
        var c = Math.floor(Math.random()*8);
        ctx.fillStyle = col1[c];
        ctx.fillRect(250, 0, 100, 100);
        
        var d = Math.floor(Math.random()*8);
        ctx.fillStyle = col1[d];
        ctx.fillRect(0, 125, 100, 100);
        
        var e = Math.floor(Math.random()*8);
        ctx.fillStyle = col1[e]; 
        ctx.fillRect(125, 125, 100, 100);
        
        var f = Math.floor(Math.random()*8);
        ctx.fillStyle = col1[f];
        ctx.fillRect(250, 125, 100, 100);


        var arr_L = [a, b, c, d, e, f]
        for(var i = 0; i < arr_L.length; ++i){
            j += (arr_L[i]+1); 
        }
        console.log("arr_L :" + j)
        // export { j };
        

    }


    function drawtext_l_incentive(l){
        var ctx = l.getContext('2d');
        var text = j
        ctx.font = "36px Times New Roman, sans-serif";
        ctx.textAlign = "center";
        ctx.fillStyle = "white"
        ctx.fillText("   " + j, 140, 100);
            }
    function drawtext_r_incentive(r){
        var ctx = r.getContext('2d');
        ctx.font = "36px Times New Roman, sans-serif";
        ctx.textAlign = "center";
        ctx.fillStyle = "white"
        ctx.fillText("   " + w, 140, 100);
            }
    var fixedvalleft = 0;

    function drawRectR(d){
        w = 0;

        var ctx = d.getContext('2d');
        ctx.beginPath();
        
        var g = Math.floor(Math.random()*8);
        ctx.fillStyle = col1[g];
        ctx.fillRect(0, 0, 100, 100);

        var h = Math.floor(Math.random()*8);
        ctx.fillStyle = col1[h];
        ctx.fillRect(125, 0, 100, 100);
        
        var i = Math.floor(Math.random()*8);
        ctx.fillStyle = col1[i];
        ctx.fillRect(250, 0, 100, 100);

        var j = Math.floor(Math.random()*8);
        ctx.fillStyle = col1[j];
        ctx.fillRect(0, 125, 100, 100);

        var k = Math.floor(Math.random()*8);
        ctx.fillStyle = col1[k];
        ctx.fillRect(125, 125, 100, 100);

        var l = Math.floor(Math.random()*8);
        ctx.fillStyle = col1[l];
        ctx.fillRect(250, 125, 100, 100);
        
        var arr_R = [g, h, i, j, k, l]
        for(var z = 0; z < arr_R.length; ++z){
            w += (arr_R[z]+1); 
        }
        console.log("arr_R :" + w)


    }


    function coverWhite(wh){
        var ctx = wh.getContext('2d');
        ctx.beginPath(); 
        var a = Math.floor(Math.random()*8);
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, 200, 200);
            }



    var n = 5; //number of training trials

    var instr1 = {
        type: 'html-keyboard-response',
        stimulus:`<p>Welcome to the study! </p>
        <p>Today, you will make some decisions about colorful objects.</p>
        <p>If you are ready to begin, please press the SPACE BAR.</p>`, //numerosity uses Space but Blair matlab code uses up arrow, which one
        choices: ['space']
    }

    var instr2 = {
        type: 'html-keyboard-response',
        stimulus:`<p>Today, your task will be to choose between two objects. </p>
        <p>To see an example, press the SPACE BAR. </p>`,
        choices: ['space']
    }

    var instr3 = {
        type: 'image-keyboard-response',
        stimulus: ['img/exampleobj.png'],
        stimulus_height: 300,
        stimulus_width: 450,
        prompt: '<p>Press the SPACE BAR to continue</p>',
        choices: ['space'],
    }

    var instr4 = {
        type: 'html-keyboard-response',
        stimulus:
        `<p>Over 200 rounds, you will be choosing the better of two objects. The value of each</p>
        <p>object is simply the sum of the values of the colored blocks in the object.</p>
        <p>Each block is valued according to its color, and each color is worth a different</p>
        <p>amount of points. Also, each color is equally likely to appear. In order to know</p>
        <p> the value of an object, you will need to learn what each color is worth.</p>
        <p>Press the SPACE BAR to continue. </p>`,
        choices: ['space']
    }

    var instr5 = {
        type: 'html-keyboard-response',
        stimulus:`<p>Each round, you will see two objects on the screen. Your task is to indicate which</p>
        <p> of the two objects you want to choose. All objects will have positive values and you will gain</p>
        <p>points based on your choices. In <b>fixed bonus rounds</b>, you will gain a bonus for choosing the better</p>
        <p>of the two options. In <b>value-based rounds</b>, you will simply gain the value of the object you selected.</p>
        <p>We will always let you know which type of round you are in before you make any chocies.</p>
        <p>Press the SPACE BAR to continue.</p>`,
        choices: ['space']
    }

    var instr6 = {
        type: 'html-keyboard-response',
        stimulus:`<p>At the end of the task, you will gain a reward based on your performance in one of the two</p>
        <p>types of rounds. You will have an equal chance of being rewarded based on the <b>fixed bonus</p>
        <p>rounds</b> or the <b>value-based rounds</b>. If the <b>fixed bonus rounds</b> are selected</p>
        <p>for pay out, you will gain the total number of points you earned for choosing the better option.</p>
        <p>If the <b>value-based rounds</b> are selected for pay out, you will gain the total number of points</p>
        <p>based on which options you selected.</p>
        <p>Press the SPACE BAR to continue.</p>`,
        choices: ['space']
    }

    var instr7 = {
        type: 'html-keyboard-response',
        stimulus:`<p>The following screen will display the colors you will see in the first</p>
        <p>few rounds. The values of the colors <b>increase</b> from left to right.</p>
        <p>Press the SPACE BAR to continue.</p>`,
        choices: ['space']
    }

var show_rainbow = {
    type: 'rainbow',
    rainbow_parameter: rainbow,
    rainbow_values_parameter: rainbow_values,
    text_parameter: rainbow_text,
    choices: ['space']
}




var instrfixed = {
        type: 'html-keyboard-response',
        stimulus:`<p>In the following rounds, you will receive a <b>fixed reward</b> for choosing the better option. </p>
        <p>You will receive ` + acc_reward + ` points for selecting the better option, and zero points for selecting the worse option.</p>
        <p>Press the SPACE BAR to continue.</p>`,
        choices: ['space']
    }

var instrincentive = {
    type: 'html-keyboard-response',
    stimulus:`<p>In the following rounds, you will receive the point value of the chosen option.</p>
    <p>You will receive no reward for selecting the better option.</p>
    <p>Press the SPACE BAR to continue.</p>`,
    choices: ['space']
}




    var instr_start_training = {
        type: 'html-keyboard-response',
        stimulus:`<p>You will now begin the training. </p>
        <p>Six random colors will appear on the left, and six random colors will appear on the right.</p>
        <p>Press <b>F</b> to select left, and press <b>J</b> to select right</p>
        <p>When you are ready, rest your fingers on <b>F</b> and <b>J</b> and</p>
        <p>Press the SPACE BAR to continue.</p>`,
        choices: ['space']
    }



    var instr_start_training_2 = {
        type: 'html-keyboard-response',
        stimulus:`<p>You will now begin the training. </p>
        <p>When you are ready, rest your fingers on <b>F</b> and <b>J</b> and</p>
        <p>Press the SPACE BAR to continue.</p>`,
        choices: ['space']
    }

    var pass_training_FR = {
        type: 'html-keyboard-response',
        stimulus: `<p> You passed the training. </p> 
        <p>You are now ready to begin the experiment. Remember, you will</p>
        <p>receive `+ acc_reward + `points for choosing the better option.</p>
        <p>When you are ready, rest your fingers on <b>F</b> and <b>J</b> and</p>
        <p>Press the SPACE BAR to start the experiment.</p>`,
        choices: ['space']
    }
    

var pass_training_VB = {
        type: 'html-keyboard-response',
        stimulus: `<p> You passed the training. </p> 
        <p>You are now ready to begin the experiment. Remember, you will</p>
        <p>receive the point value of the chosen option.</p>
        <p>When you are ready, rest your fingers on <b>F</b> and <b>J</b> and</p>
        <p>press the SPACE BAR to start the experiment.</p>`,
        choices: ['space']
    }



var fail_training_1 = {
    type: 'html-keyboard-response',
    stimulus: `<p> You failed the training. </p> 
    <p>Please remember to select the object with the higher value sum.</p>
    <p>Press <b>F</b> to select left, and press <b>J</b> to select right</p>
    <p>When you are ready, press the SPACE BAR to try the training again.</p>
    `,
    choices: ['space']
}

var fail_training_2 = {
    type: 'html-keyboard-response',
    stimulus: `<p> You failed the training. </p> 
    <p>Please remember to select the object with the higher value sum.</p>
    <p>Press <b>F</b> to select left, and press <b>J</b> to select right</p>
    <p>When you are ready, press the SPACE BAR to try the training one more time.</p>
    `,
    choices: ['space']
}

var fail_training_3 = {
    type: 'html-keyboard-response',
    stimulus: `<p> You failed the training a third try. Please do as best as you can in the experiment.</p> 
    <p></p>
    <p>Please press space to end the experiment.</p>
    `,
    choices: ['space'],
    on_finish: function(data){
        jsPsych.endExperiment('The experiment was ended after three failures.');
    }
}


var acc_VB = [];
var acc2_VB = [];
var acc3_VB = [];
var acc_FR = [];
var acc2_FR = [];
var acc3_FR = []
var idx = 0;
var idx2 = 0;
var idx3 = 0;




var trial_training = {
    type: 'blocks',
    stimulus_L: drawRectL,
    stimulus_R: drawRectR,
    text_l: drawtext_l_incentive,
    text_r: drawtext_r_incentive,
    coverWhite_f: coverWhite,
    choices: ['f','j', 'space'],
    on_finish: function(data){
        data.task = 'training';
        if(j == w){
            data.correct = 1;
        }
        if(j > w){ //if left is greater than right
            if(data.key_press == 70){
                data.correct = 1;
            }
            else{
                data.correct = 0;
            }
        }
        if(w > j){
            if(data.key_press == 74){
                data.correct = 1;
            }
            else{
                data.correct = 0;
            }
        }
        acc_VB[idx] = data.correct;
        data.acc_VB = acc_VB;
        idx++;
        data.trialN = trial_count;
        trial_count++;
    }
    //data: {shape: 'rectangle'}
};
var node_VB = {
    timeline: [fixation, trial_training],
    repetitions: n
}

//Test 2
var trial_training2 = {
        type: 'blocks',
        stimulus_L: drawRectL,
        stimulus_R: drawRectR,
        text_l: drawtext_l_incentive,
        text_r: drawtext_r_incentive,
        coverWhite_f: coverWhite,
        choices: ['f','j', 'space'],
        on_finish: function(data){
            data.task = 'training';
            if(j == w){
            data.correct = 1;
        }
        if(j > w){ //if left is greater than right
            if(data.key_press == 70){
                data.correct = 1;
            }
            else{
                data.correct = 0;
            }
        }
        if(w > j){
            if(data.key_press == 74){
                data.correct = 1;
            }
            else{
                data.correct = 0;
            }
        }
            acc2_VB[idx2] = data.correct;
            data.acc2_VB = acc2_VB;
            idx2++;
            data.trialN = trial_count;
            trial_count++;
        }
        //data: {shape: 'rectangle'}
    };
var node2 = {
    timeline: [fixation, trial_training2],
    repetitions: n
}

//Test 3
var trial_training3 = {
    type: 'blocks',
    stimulus_L: drawRectL,
    stimulus_R: drawRectR,
    text_l: drawtext_l_incentive,
    text_r: drawtext_r_incentive,
    coverWhite_f: coverWhite,
    choices: ['f','j', 'space'],
    on_finish: function(data){
        data.task = 'training';
        if(j == w){
            data.correct = 1;
        }
        if(j > w){ //if left is greater than right
            if(data.key_press == 70){
                data.correct = 1;
            }
            else{
                data.correct = 0;
            }
        }
        if(w > j){
            if(data.key_press == 74){
                data.correct = 1;
            }
            else{
                data.correct = 0;
            }
        }
        acc3_VB[idx3] = data.correct;
        data.acc3_VB = acc3_VB;
        idx3++;
        data.trialN = trial_count;
        trial_count++;
    }
    //data: {shape: 'rectangle'}
};
var node3 = {
    timeline: [fixation, trial_training3],
    repetitions: n
}



//Conditional 1
var accuracy;
var conditional_1_value = {
timeline: [fail_training_1, node2],
    conditional_function: function(){
        accuracy = 0.00;
        var counter = 0;
        for(var i = 0; i < acc_VB.length; i++){
            if(acc_VB[i]==1){
                counter++;
            }
        }
        accuracy = counter / acc_VB.length;
        if(accuracy < 0.10){ //change to .70
            return true;
        } else{ 
            return false;
        }
    }
}


//Conditional 2
var accuracy2 = 1;
var conditional_2_value = {
timeline: [fail_training_2, node3],
    conditional_function: function(){
        accuracy2 = 0.00;
        var counter2 = 0;
        for(var i = 0; i < acc2_VB.length; i++){
            if(acc2_VB[i]==1){
                counter2++;
            }
        }
        accuracy2 = counter2 / acc2_VB.length;
        if(accuracy2 < 0.70){
            return true;
        } else{ 
            timeline.push(pass_training_VB)
            return false;
        }
    }
}

//Conditional 3
var accuracy3 = 1;
var conditional_3_value = {
timeline: [fail_training_3],
    conditional_function: function(){
        accuracy3 = 0.00;
        var counter3 = 0;
        for(var i = 0; i < acc3_VB.length; i++){
            if(acc3_VB[i]==1){
                counter3++;
            }
        }
        accuracy3 = counter3 / acc3_VB.length;
        if(accuracy3 < 0.70){
            return true;
        } else{ 
            timeline.push(pass_training_VB)
            return false;
        }
    }
}


var reward_val_VB;
var reward_val_FR;
var rand_reward = [];
// var reward_val = 0;
var left_arr = []
var right_arr = []
var all_arr = []
var randidx;
acc_exp_FR = []
acc_exp_VB = []
var idx4=0;
var left_value = []
var right_value = []
var valueScore;
//Experiment
var experiment_value = {
    type: 'blocks-exp',
    stimulus_L: drawRectL,
    stimulus_R: drawRectR,
    coverWhite_f: coverWhite,
    choices: ['f','j', 'space'],
    on_finish: function(data){
        data.task = 'training';
        if(j == w){
            data.correct=1
        }
        if(j > w){ //if left is greater than right
            if(data.key_press == 70){
                data.correct = 1;
            }
            else{
                data.correct = 0;
            }
        }
        if(w > j){
            if(data.key_press == 74){
                data.correct = 1;
            }
            else{
                data.correct = 0;
            }
        }
        acc_exp_VB[idx4] = data.correct;
        data.acc_exp_VB = acc_exp_VB;
        data.trialN = trial_count;
        left_arr[idx4] = j;
        left_value[idx4] = j
        data.left_VB = left_value
        right_arr[idx4] = w;
        right_value[idx4] = w
        data.right_VB = right_value
        idx4++;
        data.trialN = trial_count;
        trial_count++;
        all_arr = left_arr.concat(right_arr);
        data.all_arr_VB = all_arr
    }

};


var experiment_node_value = {
    timeline: [fixation, experiment_value],
    repetitions: 2
}


var acc_points = 0;
var fixed_points = 0;
var value_points = 0;
    

var finish_p1_fixed_done = {
        type: 'html-keyboard-response',
        stimulus:`<p>You have completed the first half of the experiment. </p>
        <p>In this section, you earned` + fixed_points + `points.</p>
        <p>In this second half, you will be choosing <b>value-based</b></p>
        <p>Press the SPACE BAR to continue.</p>`,
        choices: ['space']
    }

    var finish_p1_value_done = {
        type: 'html-keyboard-response',
        stimulus:`<p>You have completed the first half of the experiment. </p>
        <p>In this section, you earned`+ value_points+ `points.</p>
        <p>In this second half, you will be choosing <b>value-based</b></p>
        <p>Press the SPACE BAR to continue.</p>`,
        choices: ['space']
    }


    //Make the color spectrum different
    var myfunc = function() {
        if(col1 == colors){
            col1 = colors2
        } else{
            col1 = colors;
        }
    }
    var trialm = {
        type: 'call-function',
        func: myfunc
    }

//Test 1 incentive
var trial_training_fixed = {
    type: 'blocks',
    stimulus_L: drawRectL,
    stimulus_R: drawRectR,
    text_l: drawtext_l_incentive,
    text_r: drawtext_r_incentive,
    coverWhite_f: coverWhite,
    choices: ['f','j', 'space'],
    on_finish: function(data){
        data.task = 'training';
        if(j == w){
            data.correct = 1;
        }
        if(j > w){ //if left is greater than right
            if(data.key_press == 70){
                data.correct = 1;
            }
            else{
                data.correct = 0;
            }
        }
        if(w > j){
            if(data.key_press == 74){
                data.correct = 1;
            }
            else{
                data.correct = 0;
            }
        }
        acc_FR[idx] = data.correct;
        data.acc_FR = acc_FR;
        idx++;
        data.trialN = trial_count;
        trial_count++;
    }
    //data: {shape: 'rectangle'}
};
var node_fixed = {
    timeline: [fixation, trial_training_fixed],
    repetitions: n
}


//Test 2
var trial_training2_fixed = {
        type: 'blocks',
        stimulus_L: drawRectL,
        stimulus_R: drawRectR,
        text_l: drawtext_l_incentive,
        text_r: drawtext_r_incentive,
        coverWhite_f: coverWhite,
        choices: ['f','j', 'space'],
        on_finish: function(data){
            data.task = 'training';
            if(j == w){
            data.correct = 1;
        }
        if(j > w){ //if left is greater than right
            if(data.key_press == 70){
                data.correct = 1;
            }
            else{
                data.correct = 0;
            }
        }
        if(w > j){
            if(data.key_press == 74){
                data.correct = 1;
            }
            else{
                data.correct = 0;
            }
        }
            acc2_FR[idx2] = data.correct;
            data.acc2_FR = acc2_FR;
            idx2++;
            data.trialN = trial_count;
            trial_count++;
        }
        //data: {shape: 'rectangle'}
    };
var node2_fixed = {
    timeline: [fixation, trial_training2_fixed],
    repetitions: n
}

//Test 3
var trial_training3_fixed = {
    type: 'blocks',
    stimulus_L: drawRectL,
    stimulus_R: drawRectR,
    text_l: drawtext_l_incentive,
    text_r: drawtext_r_incentive,
    coverWhite_f: coverWhite,
    choices: ['f','j', 'space'],
    on_finish: function(data){
        data.task = 'training';
        if(j == w){
            data.correct = 1;
        }
        if(j > w){ //if left is greater than right
            if(data.key_press == 70){
                data.correct = 1;
            }
            else{
                data.correct = 0;
            }
        }
        if(w > j){
            if(data.key_press == 74){
                data.correct = 1;
            }
            else{
                data.correct = 0;
            }
        }
        acc3_FR[idx3] = data.correct;
        data.acc3_FR = acc3_FR;
        idx3++;
        data.trialN = trial_count;
        trial_count++;
    }
    //data: {shape: 'rectangle'}
};
var node3_fixed = {
    timeline: [fixation, trial_training3_fixed],
    repetitions: n
}


var pass_FR;

//Conditional 1
var accuracy;
var conditional_1_fixed = {
timeline: [fail_training_1, node2_fixed],
    conditional_function: function(){
        accuracy = 0.00;
        var counter = 0;
        for(var i = 0; i < acc_FR.length; i++){
            if(acc_FR[i]==1){
                counter++;
            }
        }
        accuracy = counter / acc_FR.length;
        if(accuracy < 0.10){ //change to .70
            return true;
        } else{ 
            pass_FR = true;
            return false;
        }
    }
}



//Conditional 2
var accuracy2 = 1;
var conditional_2_fixed = {
timeline: [fail_training_2, node3_fixed],
    conditional_function: function(){
        accuracy2 = 0.00;
        var counter2 = 0;
        for(var i = 0; i < acc2_FR.length; i++){
            if(acc2_FR[i]==1){
                counter2++;
            }
        }
        accuracy2 = counter2 / acc2_FR.length;
        if(accuracy2 < 0.70){
            return true;
        } else{ 
            console.log("test")
            pass_FR = true;
            return false;
        }
    }
}


//Conditional 3
var accuracy3 = 1;
var conditional_3_fixed = {
timeline: [fail_training_3],
    conditional_function: function(){
        accuracy3 = 0.00;
        var counter3 = 0;
        for(var i = 0; i < acc3_FR.length; i++){
            if(acc3_FR[i]==1){
                counter3++;
            }
        }
        accuracy3 = counter3 / acc3_FR.length;
        if(accuracy3 < 0.70){
            return true;
        } else{ 
            console.log("test")
            pass_FR = true;
            return false;
        }
    }
}



//150 trials of main task

// timeline.push(pass_training_FR) //?


    //Make the color spectrum different
    var myfunc2 = function() {
        if(pass_FR){
            timeline.push(pass_training_FR)
        }
    }
    var trialm2 = {
        type: 'call-function',
        func: myfunc2
    }


var reward_val;
var rand_reward = [];
// var reward_val = 0;
var left_arr = []
var right_arr = []
var all_arr = []
var randidx;
var idx5=0;
var left_fixed = []
var right_fixed = []
//Experiment
var experiment_fixed = {
    type: 'blocks-exp',
    stimulus_L: drawRectL,
    stimulus_R: drawRectR,
    coverWhite_f: coverWhite,
    choices: ['f','j', 'space'],
    on_finish: function(data){
        data.task = 'training';
        if(j == w){
            data.correct=1
        }
        if(j > w){ //if left is greater than right
            if(data.key_press == 70){
                data.correct = 1;
            }
            else{
                data.correct = 0;
            }
        }
        if(w > j){
            if(data.key_press == 74){
                data.correct = 1;
            }
            else{
                data.correct = 0;
            }
        }
        acc_exp_FR[idx5] = data.correct;
        data.acc_exp_FR = acc_exp_FR;
        data.trialN = trial_count;
        // left_arr[idx5] = j;
        left_fixed[idx5] = j
        data.left_FR = left_fixed //change to j for just one
        // right_arr[idx5] = w;
        right_fixed[idx5] = w
        data.right_FR = right_fixed //change to w for just one
        idx5++;
        data.trialN = trial_count;
        trial_count++;
        // all_arr = left_arr.concat(right_arr);
        
    }
    //data: {shape: 'rectangle'}
};


var experiment_node_fixed = {
    timeline: [fixation, experiment_fixed],
    repetitions: 2
}
// timeline.push(experiment_node_fixed)


//Instructions
var instr_arr = [instr1, instr2, instr3, instr4, instr5, instr6, instr7]
timeline = timeline.concat(instr_arr)



if(fixedfirst==true){
    timeline.push(show_rainbow)
    timeline.push(instrfixed)
    timeline.push(instr_start_training)
    timeline.push(node_fixed)
    timeline.push(conditional_1_fixed)
    timeline.push(conditional_2_fixed)
    timeline.push(conditional_3_fixed)
    timeline.push(pass_training_FR)
    timeline.push(experiment_node_fixed)
    timeline.push(finish_p1_fixed_done)
    timeline.push(trialm)

    timeline.push(instrincentive)
    timeline.push(show_rainbow)
    timeline.push(instrincentive)
    timeline.push(instr_start_training_2)
    timeline.push(node_VB)
    timeline.push(conditional_1_value)
    timeline.push(conditional_2_value)
    timeline.push(conditional_3_value)
    timeline.push(pass_training_VB)
    // timeline.push(pass_training_VB)
    timeline.push(experiment_node_value)
} else{
    timeline.push(show_rainbow)
    timeline.push(instrincentive)
    timeline.push(instr_start_training_2)
    timeline.push(node_VB)
    timeline.push(conditional_1_value)
    timeline.push(conditional_2_value)
    timeline.push(conditional_3_value)
    timeline.push(pass_training_VB)
    timeline.push(experiment_node_value)
    timeline.push(finish_p1_value_done)
    timeline.push(trialm)

    timeline.push(instrfixed)
    timeline.push(instr_start_training)
    timeline.push(node_fixed)
    timeline.push(conditional_1_fixed)
    timeline.push(conditional_2_fixed)
    timeline.push(conditional_3_fixed)
    timeline.push(pass_training_FR)
    timeline.push(experiment_node_fixed)
}


var reward_is_VB;
var reward_is_FR;
if(Math.random() < .5){
    reward_is_VB = true;
} else{
    reward_is_FR = true;
}

var reward_function_VB = function(){
        randidx = Math.floor(Math.random() * all_arr.length)
        var reward_val_VB = all_arr[randidx]
        console.log(reward_val_VB)
        return reward_val_VB
}

var reward_node_VB = {
    type: 'call-function',
    func: reward_function_VB,
    on_finish: function(data){
        data.randidx = randidx;
        data.reward_val_VB = reward_val_VB;
    }
}
timeline.push(reward_node_VB)
var randidx_FR;
var final_reward_boolean;
var final_reward;
var reward_function_FR = function(){
        randidx_FR = Math.floor(Math.random() * acc_exp_FR.length)
        var final_reward_boolean = acc_exp_FR[randidx_FR]
        if(final_reward_boolean == 1){
            if(left_fixed[randidx] > right_fixed[randidx_FR]){
                final_reward_value = left_fixed[randidx_FR];
            }else{
                final_reward_value = right_fixed[randidx_FR]
            }
        } else{
            final_reward_value = 0;
        }

        return final_reward_value;
}

var reward_node_FR = {
    type: 'call-function',
    func: reward_function_FR,
    on_finish: function(data){
        data.randidx_FR = randidx_FR;
        data.left_FR = left_fixed;
        data.right_FR = right_fixed;
        data.final_reward_value = final_reward_value;
        data.final_reward_boolean = final_reward_boolean
        data.fixed_acc = acc_exp_FR
    }
}
timeline.push(reward_node_FR)



var reward_VB = {
        type: 'html-keyboard-response',
        choices: ['space'],
        on_start: function(trial){
            trial.stimulus = `<p> You have completed the experiment! </p> 
        <p>Your reward will be from the value-based trials..</p>    
        <p>One correct trial was selected at random, and you are rewarded the value of that choice.</p>
        <p>Your reward is $` + reward_function_VB() + `.</p>`
        }
    }
if(reward_is_VB){
    timeline.push(reward_VB)
}

var reward_FR_correct = {
        type: 'html-keyboard-response',
        choices: ['space'],
        on_start: function(trial){
            trial.stimulus = `<p> You have completed the experiment! </p> \
        <p>Your reward will be from the fixed-reward trials..</p>    
        <p>One trial was selected at random, which you got correct!.</p>
        <p>Your reward is $` + reward_function_FR() + `.</p>`
        }
    }

var reward_FR_incorrect = {
        type: 'html-keyboard-response',
        choices: ['space'],
        on_start: function(trial){
            trial.stimulus = `<p> You have completed the experiment! </p> \
        <p>Your reward will be from the fixed-reward trials..</p>    
        <p>One trial was selected at random, which you unfortunately did not get correct.</p>
        <p>Your reward is $` + reward_function_FR() + `.</p>`
        }
    }

if(reward_is_FR){
    if(reward_val_FR == 0){
        timeline.push(reward_FR_incorrect)
    } else{
        timelien.push(reward_FR_correct)
    }
}






    jsPsych.init({
        timeline,
        on_finish: function () { 
            jsPsych.data.displayData();
            jsPsych.data.get().localSave('csv','mydata.csv'); 
        }
    });
</script>
</html>
